# Code to switch between user and kernel space.
#
# This code is mapped at the same virtual address
# (TRAMPOLINE) ins user and kernel space so that
# it containes to work when it switches page tables.
#
# linker.ld causes this to be aligned to a page
# boundary.

.section .text.trampoline_section

.global trampoline
trampoline:

.align 4
.global uservec
uservec:
    # sscratch points to where the process's p->trapframe is mapped
    # into user space, at TRAPFRAME

    # Swap a0 and sscratch, so that a0 is TRAPFRAME
    csrrw   a0, sscratch, a0

    # Save the user registers in TRAPFRAME
    sd  ra, 40(a0)
    sd  sp, 48(a0)
    sd  gp, 56(a0)
    sd  tp, 64(a0)
    sd  t0, 72(a0)
    sd  t1, 80(a0)
    sd  t2, 88(a0)
    sd  s0, 96(a0)
    sd  s1, 104(a0)
    sd  a1, 120(a0)
    sd  a2, 128(a0)
    sd  a3, 136(a0)
    sd  a4, 144(a0)
    sd  a5, 152(a0)
    sd  a6, 160(a0)
    sd  a7, 168(a0)
    sd  s2, 176(a0)
    sd  s3, 184(a0)
    sd  s4, 192(a0)
    sd  s5, 200(a0)
    sd  s6, 208(a0)
    sd  s7, 216(a0)
    sd  s8, 224(a0)
    sd  s9, 232(a0)
    sd  s10, 240(a0)
    sd  s11, 248(a0)
    sd  t3, 256(a0)
    sd  t4, 264(a0)
    sd  t5, 272(a0)
    sd  t6, 280(a0)

    # Save the user a0 in p->trapframe->a0
    csrr    t0, sscratch
    sd  t0, 112(a0)

    # Initialize kernel stack pointer, from p->trapframe->kernel_sp
    ld  sp, 8(a0)

    # Make tp hold the current hartid, from p->trapframe->kernel_hartid
    ld  tp, 32(a0)

    # Load the address of usertrap(), p->trapframe->kernel_trap
    ld  t0, 16(a0)

    # Fetch the kernel page table address, from p->trapframe->kernel_satp.
    ld  t1, 0(a0)

    # Wait for any previous memory operations to complete, so that
    # they use the user page table. Then, install the kernel page table
    # and flush TLB.
    # sfence.vma  zero, zero
    csrw        satp, t1
    sfence.vma  zero, zero

    # jump to usertrap(), which does not return
    jr  t0

.align 4
.global userret
userret:
    # Userret(trapframe, pagetable) called by usertrapret to switch from
    # kernel to user.

    # Switch to the user page table.
    # sfence.vma  zero, zero

    csrw    satp, a1
    sfence.vma  zero, zero

    # Put the saved user a0 in sscratch, so we can swap it with our
    # a0 (TRAPFRAME) in the last step.
    ld  t0, 112(a0)
    csrw    sscratch, t0

    # Restore all but a0 from TRAPFRAME
    ld  ra, 40(a0)
    ld  sp, 48(a0)
    ld  gp, 56(a0)
    ld  tp, 64(a0)
    ld  t0, 72(a0)
    ld  t1, 80(a0)
    ld  t2, 88(a0)
    ld  s0, 96(a0)
    ld  s1, 104(a0)
    ld  a1, 120(a0)
    ld  a2, 128(a0)
    ld  a3, 136(a0)
    ld  a4, 144(a0)
    ld  a5, 152(a0)
    ld  a6, 160(a0)
    ld  a7, 168(a0)
    ld  s2, 176(a0)
    ld  s3, 184(a0)
    ld  s4, 192(a0)
    ld  s5, 200(a0)
    ld  s6, 208(a0)
    ld  s7, 216(a0)
    ld  s8, 224(a0)
    ld  s9, 232(a0)
    ld  s10, 240(a0)
    ld  s11, 248(a0)
    ld  t3, 256(a0)
    ld  t4, 264(a0)
    ld  t5, 272(a0)
    ld  t6, 280(a0)

    # Restore user a0, and save TRAPFRAME in sscratch
    csrrw   a0, sscratch, a0

    # Return to user mode and user pc.
    # usertrapret() set up sstatus and sepc.
    sret
